

#  Sandboxed Malware Analyzer (Static + Dynamic Lite)

## Overview

This project is part of my **C-Learning-Journey**, where I explore system programming, secure coding, and cybersecurity applications in C.

The goal of this project is to build a **lightweight malware analyzer** that can:

1. **Static analysis** – Parse and print ELF binary metadata (headers, sections, imports, entropy, strings).
2. **Dynamic analysis** – Optionally execute the binary in a **restricted sandbox** with resource limits, syscall filters, and isolation.
3. **Reporting** – Produce structured output (JSON) with indicators and findings useful for SOC workflows.

 **Disclaimer**: This sandbox is for **educational purposes only**. Do not run real-world malware on your main machine. Always test inside a VM.

---

##  Features

* **Static Analysis**

  * File hashes (SHA-256).
  * ELF header + section inspection.
  * Imported libraries & symbols.
  * Entropy calculation for packer detection.
  * String extraction (IPs, URLs, suspicious keywords).

* **Dynamic Analysis (Sandbox Lite)**

  * Run binary with **CPU/memory/time limits**.
  * Block/allow network syscalls.
  * Syscall tracing with `ptrace`.
  * Isolate with Linux namespaces + `chroot`.

* **Security Twist**

  * Detects suspicious sections (W+X flags, high entropy).
  * Flags ICS/OT-related strings (e.g., “modbus”, “/dev/ttyS*”).
  * Rejects modified/tampered ELF headers.

---

##  Build & Run

```bash
# Clone the repo
git clone https://github.com/IbraDevOps/C-Learning-Journey.git
cd Malware_Analyzer

# Build (with GCC + OpenSSL for crypto)
make

# Run static analysis
./malx static suspicious.bin

# Run in sandbox (5s timeout, no network)
./malx run suspicious.bin --timeout 5 --no-net --json
```

Output is saved as `REPORT.json`.

---

##  Project Structure

```
Malware_Analyzer/
├── src/
│   ├── main.c          # Entry point & CLI
│   ├── elf_parser.c    # ELF parsing logic
│   ├── static.c        # Static analysis module
│   ├── sandbox.c       # Isolation & limits
│   ├── ptrace.c        # Syscall logging
│   ├── report.c        # JSON output
│   └── utils.c         # Helpers (hashing, entropy, strings)
├── include/            # Header files
├── tests/              # Unit tests
├── Makefile            # Build rules
└── README.md           # Project doc
```

---

##  Roadmap

*  Phase 1 – Static ELF parsing & reporting.
*  Phase 2 – Sandbox execution with `rlimit`.
*  Phase 3 – Syscall tracing via `ptrace`.
*  Phase 4 – Add namespaces + chroot.
*  Phase 5 – Rules engine for suspicious indicators.
*  Phase 6 – GitHub Actions CI/CD.

---

##  GitHub Actions (CI/CD)

This project uses GitHub Actions to automatically:

* Build the project with `make`.
* Run static analysis (clang-tidy, cppcheck).
* Run tests under `valgrind` + sanitizers (ASAN/UBSAN).

Add this file as `.github/workflows/ci.yml`:

```yaml
name: CI

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repo
      uses: actions/checkout@v3

    - name: Install dependencies
      run: sudo apt-get update && sudo apt-get install -y build-essential valgrind cppcheck clang

    - name: Build
      run: make

    - name: Run unit tests
      run: |
        make test || true

    - name: Run static analysis
      run: |
        cppcheck --enable=all --error-exitcode=1 src

    - name: Run under Valgrind
      run: |
        valgrind --leak-check=full ./tests/test_malx || true
```

---

##  Security & Ethics

* **Educational use only.**
* Always run in an **isolated VM**.
* Not production-grade.
* No guarantees against sandbox escapes.

---

##  Conclusion

This project demonstrates how C can be used for **security tooling**—parsing binaries, interacting with the OS, and enforcing isolation. It is a bridge between **low-level programming** and **applied cybersecurity research**.


