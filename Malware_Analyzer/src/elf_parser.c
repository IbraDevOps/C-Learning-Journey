#include "elfx.h"
#include "utils.h"
#include <elf.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
static const char* machine_name(uint16_t m) {
    switch (m) {
        case EM_X86_64: return "x86_64";
        case EM_386:    return "x86";
        case EM_AARCH64:return "aarch64";
        case EM_ARM:    return "arm";
        default:        return "unknown";
    }
}

int elf_summarize(const char *path, struct elf_summary *out, char *err, size_t errlen) {
    unsigned char *buf=NULL; size_t len=0; int rc=-1;
    if (read_file(path, &buf, &len, err, errlen) != 0) return -1;
    if (len < 4 || memcmp(buf, "\x7f""ELF", 4) != 0) { snprintf(err, errlen, "not an ELF file"); goto done; }

    unsigned char ei_class = buf[EI_CLASS];
    unsigned char ei_data  = buf[EI_DATA];

    if (ei_class == ELFCLASS64) {
        if (len < sizeof(Elf64_Ehdr)) { snprintf(err, errlen, "truncated ELF64 header"); goto done; }
        const Elf64_Ehdr *eh = (const Elf64_Ehdr*)buf;
        snprintf(out->class_str, sizeof out->class_str, "ELF64");
        snprintf(out->endian_str, sizeof out->endian_str, (ei_data==ELFDATA2LSB)?"LE":(ei_data==ELFDATA2MSB?"BE":"?"));
        snprintf(out->machine, sizeof out->machine, "%s", machine_name(eh->e_machine));
        out->entry = eh->e_entry;
        out->pie = (eh->e_type == ET_DYN);
        out->has_symtab = false;
        if (eh->e_shoff && eh->e_shentsize == sizeof(Elf64_Shdr) &&
            eh->e_shnum*sizeof(Elf64_Shdr) + eh->e_shoff <= len) {
            const Elf64_Shdr *sh = (const Elf64_Shdr*)(buf + eh->e_shoff);
            for (int i = 0; i < eh->e_shnum; ++i) if (sh[i].sh_type == SHT_SYMTAB) { out->has_symtab = true; break; }
        }
        rc = 0;
    } else if (ei_class == ELFCLASS32) {
        if (len < sizeof(Elf32_Ehdr)) { snprintf(err, errlen, "truncated ELF32 header"); goto done; }
        const Elf32_Ehdr *eh = (const Elf32_Ehdr*)buf;
        snprintf(out->class_str, sizeof out->class_str, "ELF32");
        snprintf(out->endian_str, sizeof out->endian_str, (ei_data==ELFDATA2LSB)?"LE":(ei_data==ELFDATA2MSB?"BE":"?"));
        snprintf(out->machine, sizeof out->machine, "%s", machine_name(eh->e_machine));
        out->entry = eh->e_entry;
        out->pie = (eh->e_type == ET_DYN);
        out->has_symtab = false;
        if (eh->e_shoff && eh->e_shentsize == sizeof(Elf32_Shdr) &&
            (size_t)eh->e_shnum*sizeof(Elf32_Shdr) + eh->e_shoff <= len) {
            const Elf32_Shdr *sh = (const Elf32_Shdr*)(buf + eh->e_shoff);
            for (int i = 0; i < eh->e_shnum; ++i) if (sh[i].sh_type == SHT_SYMTAB) { out->has_symtab = true; break; }
        }
        rc = 0;
    } else {
        snprintf(err, errlen, "unknown ELF class");
    }

done:
    free(buf);
    return rc;
}
