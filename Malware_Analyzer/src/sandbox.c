//#define _GNU_SOURCE
#include <errno.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

#ifndef NO_SECCOMP
#include <seccomp.h>
#endif

#include "sandbox.h"
#include "jail.h"

static int apply_limits(const struct limits *lim) {
    struct rlimit rl;

    if (lim->timeout_sec > 0) {
        /* CPU seconds (best-effort); we also enforce wall-clock in parent */
        rl.rlim_cur = rl.rlim_max = lim->timeout_sec;
        if (setrlimit(RLIMIT_CPU, &rl) != 0) return -1;
    }
    if (lim->mem_bytes > 0) {
        rl.rlim_cur = rl.rlim_max = (rlim_t)lim->mem_bytes;
        if (setrlimit(RLIMIT_AS, &rl) != 0) return -1;
    }
    if (lim->fsize_bytes > 0) {
        rl.rlim_cur = rl.rlim_max = (rlim_t)lim->fsize_bytes;
        if (setrlimit(RLIMIT_FSIZE, &rl) != 0) return -1;
    }
    if (lim->nofile > 0) {
        rl.rlim_cur = rl.rlim_max = (rlim_t)lim->nofile;
        if (setrlimit(RLIMIT_NOFILE, &rl) != 0) return -1;
    }
    return 0;
}

static void set_no_new_privs(void) {
    (void)prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
}

#ifndef NO_SECCOMP
static int apply_seccomp_no_net(void) {
    scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_ALLOW);
    if (!ctx) return -1;

    int rc = 0;
    rc |= seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(socket),   0);
    rc |= seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(connect),  0);
    rc |= seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(accept),   0);
    rc |= seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(accept4),  0);
    rc |= seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(bind),     0);
    rc |= seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(listen),   0);
    rc |= seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(getsockopt),0);
    rc |= seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(setsockopt),0);
    rc |= seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(sendto),   0);
    rc |= seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(recvfrom), 0);
    rc |= seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(sendmsg),  0);
    rc |= seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(recvmsg),  0);
    rc |= seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(shutdown), 0);

    if (rc) { seccomp_release(ctx); return -1; }
    if (seccomp_load(ctx) != 0) { seccomp_release(ctx); return -1; }
    seccomp_release(ctx);
    return 0;
}
#else
static int apply_seccomp_no_net(void) { errno = ENOSYS; return -1; }
#endif

static long now_ms(void) {
    struct timespec ts; clock_gettime(CLOCK_MONOTONIC, &ts);
    return (long)(ts.tv_sec * 1000LL + ts.tv_nsec / 1000000LL);
}

int run_in_sandbox(const char *path, char *const argv[],
                   const struct limits *lim, int no_net,
                   int use_jail,
                   struct run_result *out) {
    pid_t pid = fork();
    if (pid < 0) return -1;

    long t0 = now_ms();
    int status = 0;

    if (pid == 0) {
        /* Child: optional jail first, then apply limits/seccomp, then exec */
        if (use_jail) {
            char jerr[256]={0};
            struct jail_opts jopt = { .root=NULL, .make_netns=0, .readonly=1 };
            if (jail_enter(&jopt, jerr, sizeof jerr) != 0) _exit(127);
        }

        if (apply_limits(lim) != 0) _exit(127);
        set_no_new_privs();
        if (no_net) (void)apply_seccomp_no_net(); /* best-effort */
        execv(path, argv);
        _exit(127); /* exec failed */
    }

    /* Parent: supervise and kill on wall-clock timeout */
    int timed_out = 0;
    while (1) {
        pid_t r = waitpid(pid, &status, WNOHANG);
        if (r == pid) break;              /* child finished */
        if (r == 0) {                     /* still running */
            if (lim->timeout_sec > 0) {
                long elapsed = now_ms() - t0;
                if (elapsed >= (long)lim->timeout_sec * 1000L) {
                    timed_out = 1;
                    kill(pid, SIGKILL);
                    (void)waitpid(pid, &status, 0);
                    break;
                }
            }
            usleep(10000);
            continue;
        }
        if (r < 0 && errno != EINTR) break;
    }

    long t1 = now_ms();
    out->elapsed_ms = t1 - t0;
    out->killed_by_timeout = timed_out;
    out->exit_code = WIFEXITED(status) ? WEXITSTATUS(status) : -1;
    out->term_signal = WIFSIGNALED(status) ? WTERMSIG(status) : 0;
    return 0;
}
