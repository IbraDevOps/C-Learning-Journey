#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "report.h"
#include "utils.h"
#include "elfx.h"
#include "sandbox.h"
#include "trace.h"

/* ---- Phase 1: static subcommand ---- */
static int cmd_static(int argc, char **argv) {
    if (argc < 1) {
        fprintf(stderr, "Usage: ./malx static <file> [--json] [--pretty]\n");
        return 2;
    }
    const char *path = argv[0];
    int json = 0, pretty = 0;
    for (int i = 1; i < argc; ++i) {
        if (!strcmp(argv[i], "--json"))   json = 1;
        else if (!strcmp(argv[i], "--pretty")) pretty = 1;
    }

    struct elf_summary sum;
    char err[256] = {0};
    if (elf_summarize(path, &sum, err, sizeof(err)) != 0) {
        fprintf(stderr, "ELF parse failed: %s\n", err[0] ? err : path);
        return 1;
    }

    unsigned char *buf = NULL; size_t len = 0;
    if (read_file(path, &buf, &len, err, sizeof(err)) != 0) {
        fprintf(stderr, "read_file failed: %s\n", err[0] ? err : path);
        return 1;
    }
    char sha256[65] = {0};
    if (sha256_hex(buf, len, sha256) != 0) {
        free(buf);
        fprintf(stderr, "sha256_hex failed\n");
        return 1;
    }
    free(buf);

    struct report_opts opt = { .json = json, .pretty = pretty };
    print_static_report(path, sha256, &sum, &opt);
    return 0;
}

/* ---- Phase 2 + 4: run subcommand (rlimit + optional jail + optional no-net) ---- */
static int cmd_run(int argc, char **argv) {
    if (argc < 1) {
        fprintf(stderr, "usage: ./malx run <path> [--timeout SEC] [--mem MB] [--no-net] [--jail] [--json] [--pretty] [--] [args...]\n");
        return 2;
    }
    const char *path = argv[0];
    struct limits lim = { .timeout_sec = 5, .mem_bytes = 256L*1024*1024, .fsize_bytes = 16L*1024*1024, .nofile = 64 };
    int no_net = 0, json = 0, pretty = 0, use_jail = 0;

    int sep = -1;
    for (int i = 1; i < argc; i++) {
        if (!strcmp(argv[i], "--")) { sep = i; break; }
        else if (!strcmp(argv[i], "--timeout") && i+1 < argc) lim.timeout_sec = atoi(argv[++i]);
        else if (!strcmp(argv[i], "--mem")     && i+1 < argc) lim.mem_bytes  = atol(argv[++i]) * 1024L * 1024L;
        else if (!strcmp(argv[i], "--no-net"))  no_net = 1;
        else if (!strcmp(argv[i], "--jail"))    use_jail = 1;
        else if (!strcmp(argv[i], "--json"))    json = 1;
        else if (!strcmp(argv[i], "--pretty"))  pretty = 1;
    }

    int child_argc = 1 + ((sep >= 0) ? (argc - sep - 1) : 0);
    char **child_argv = calloc(child_argc + 1, sizeof(char*));
    if (!child_argv) { perror("calloc"); return 1; }
    child_argv[0] = (char*)path;
    if (sep >= 0) for (int i = 0; i < argc - sep - 1; i++) child_argv[1+i] = argv[sep+1+i];
    child_argv[child_argc] = NULL;

    struct run_result rr = {0};
    if (run_in_sandbox(path, child_argv, &lim, no_net, use_jail, &rr) != 0) {
        fprintf(stderr, "run failed\n");
        free(child_argv);
        return 1;
    }
    free(child_argv);

    if (json) {
        if (pretty) {
            printf("{\n  \"run\": {\n    \"path\": \"%s\",\n    \"exit_code\": %d,\n    \"term_signal\": %d,\n    \"timeout\": %s,\n    \"elapsed_ms\": %ld\n  }\n}\n",
                   path, rr.exit_code, rr.term_signal, rr.killed_by_timeout ? "true":"false", rr.elapsed_ms);
        } else {
            printf("{\"run\":{\"path\":\"%s\",\"exit_code\":%d,\"term_signal\":%d,\"timeout\":%s,\"elapsed_ms\":%ld}}\n",
                   path, rr.exit_code, rr.term_signal, rr.killed_by_timeout ? "true":"false", rr.elapsed_ms);
        }
    } else {
        printf("ran %s  exit=%d  sig=%d  timeout=%d  elapsed=%ldms\n",
               path, rr.exit_code, rr.term_signal, rr.killed_by_timeout, rr.elapsed_ms);
    }
    return 0;
}

/* ---- Phase 3 + 4: trace subcommand (ptrace + optional jail) ---- */
static int cmd_trace(int argc, char **argv){
    if(argc < 1){
        fprintf(stderr, "usage: ./malx trace <path> [--timeout SEC] [--max N] [--jail] [--json] [--pretty] [--] [args...]\n");
        return 2;
    }
    const char *path = argv[0];
    int timeout = 5, maxev = 200, json=1, pretty=0, use_jail=0;

    int sep = -1;
    for(int i=1;i<argc;i++){
        if(!strcmp(argv[i],"--")) { sep = i; break; }
        else if(!strcmp(argv[i],"--timeout") && i+1<argc) timeout = atoi(argv[++i]);
        else if(!strcmp(argv[i],"--max")     && i+1<argc) maxev   = atoi(argv[++i]);
        else if(!strcmp(argv[i],"--jail"))   use_jail = 1;
        else if(!strcmp(argv[i],"--json"))   json   = 1;
        else if(!strcmp(argv[i],"--pretty")) pretty = 1;
    }

    int child_argc = 1 + ((sep>=0)? (argc - sep - 1) : 0);
    char **child_argv = calloc(child_argc + 1, sizeof(char*));
    if(!child_argv){ perror("calloc"); return 1; }
    child_argv[0] = (char*)path;
    if(sep>=0) for(int i=0;i<argc-sep-1;i++) child_argv[1+i] = argv[sep+1+i];
    child_argv[child_argc] = NULL;

    struct trace_opts topt = { .timeout_sec = timeout, .max_events = maxev, .json = json, .pretty = pretty, .jail = use_jail };
    int rc = trace_process(path, child_argv, &topt);
    free(child_argv);
    return rc;
}

int main(int argc, char **argv) {
    if (argc < 2) {
        fprintf(stderr, "Usage:\n  ./malx static <file> [--json] [--pretty]\n  ./malx run <path> [--timeout SEC] [--mem MB] [--no-net] [--jail] [--json] [--pretty] [--] [args...]\n  ./malx trace <path> [--timeout SEC] [--max N] [--jail] [--json] [--pretty] [--] [args...]\n");
        return 2;
    }
    if (!strcmp(argv[1], "static")) return cmd_static(argc-2, &argv[2]);
    if (!strcmp(argv[1], "run"))    return cmd_run   (argc-2, &argv[2]);
    if (!strcmp(argv[1], "trace"))  return cmd_trace (argc-2, &argv[2]);
    fprintf(stderr, "unknown subcommand: %s\n", argv[1]);
    return 2;
}
