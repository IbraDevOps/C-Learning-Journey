#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "report.h"
#include "utils.h"
#include "elfx.h"
#include "sandbox.h"
#include "trace.h"

/* -------- Version / exit codes -------- */
#ifndef MALX_VERSION
#define MALX_VERSION "1.0.0"
#endif

#define EX_OK       0   /* success */
#define EX_USAGE    1   /* bad args */
#define EX_IO       2   /* file/ELF/hash error */
#define EX_SANDBOX  3   /* jail/perm/runtime error */
#define EX_TIMEOUT  124 /* timed out (common convention) */

/* -------- Common usage text -------- */
static void print_usage(void) {
    fprintf(stderr,
        "malx " MALX_VERSION "\n"
        "Usage:\n"
        "  malx --help | --version\n"
        "  malx static <file> [--json] [--pretty]\n"
        "  malx run    <path> [--timeout SEC] [--mem MB] [--no-net] [--jail] [--json] [--pretty] [--] [args...]\n"
        "  malx trace  <path> [--timeout SEC] [--max N] [--jail] [--json] [--pretty] [--] [args...]\n"
    );
}

/* =======================
 * Phase 1: static
 * ======================= */
static int cmd_static(int argc, char **argv) {
    if (argc < 1) {
        fprintf(stderr, "Usage: malx static <file> [--json] [--pretty]\n");
        return EX_USAGE;
    }

    const char *path = argv[0];
    int json = 0, pretty = 0;
    for (int i = 1; i < argc; ++i) {
        if (!strcmp(argv[i], "--json"))   json = 1;
        else if (!strcmp(argv[i], "--pretty")) pretty = 1;
    }

    struct elf_summary sum;
    char err[256] = {0};

    if (elf_summarize(path, &sum, err, sizeof(err)) != 0) {
        fprintf(stderr, "ELF parse failed: %s\n", err[0] ? err : path);
        return EX_IO;
    }

    unsigned char *buf = NULL; size_t len = 0;
    if (read_file(path, &buf, &len, err, sizeof(err)) != 0) {
        fprintf(stderr, "read_file failed: %s\n", err[0] ? err : path);
        return EX_IO;
    }

    char sha256[65] = {0};
    if (sha256_hex(buf, len, sha256) != 0) {
        free(buf);
        fprintf(stderr, "sha256_hex failed\n");
        return EX_IO;
    }
    free(buf);

    struct report_opts opt = { .json = json, .pretty = pretty };
    print_static_report(path, sha256, &sum, &opt);
    return EX_OK;
}

/* =======================
 * Phase 2 + 4: run (rlimit + optional jail/no-net)
 * ======================= */
static int cmd_run(int argc, char **argv) {
    if (argc < 1) {
        fprintf(stderr, "Usage: malx run <path> [--timeout SEC] [--mem MB] [--no-net] [--jail] [--json] [--pretty] [--] [args...]\n");
        return EX_USAGE;
    }

    const char *path = argv[0];
    struct limits lim = { .timeout_sec = 5, .mem_bytes = 256L*1024*1024, .fsize_bytes = 16L*1024*1024, .nofile = 64 };
    int no_net = 0, json = 0, pretty = 0, use_jail = 0;

    int sep = -1;
    for (int i = 1; i < argc; i++) {
        if (!strcmp(argv[i], "--")) { sep = i; break; }
        else if (!strcmp(argv[i], "--timeout") && i+1 < argc) lim.timeout_sec = atoi(argv[++i]);
        else if (!strcmp(argv[i], "--mem")     && i+1 < argc) lim.mem_bytes  = atol(argv[++i]) * 1024L * 1024L;
        else if (!strcmp(argv[i], "--no-net"))  no_net = 1;
        else if (!strcmp(argv[i], "--jail"))    use_jail = 1;
        else if (!strcmp(argv[i], "--json"))    json = 1;
        else if (!strcmp(argv[i], "--pretty"))  pretty = 1;
    }

    int child_argc = 1 + ((sep >= 0) ? (argc - sep - 1) : 0);
    char **child_argv = calloc(child_argc + 1, sizeof(char*));
    if (!child_argv) { perror("calloc"); return EX_SANDBOX; }
    child_argv[0] = (char*)path;
    if (sep >= 0) for (int i = 0; i < argc - sep - 1; i++) child_argv[1+i] = argv[sep+1+i];
    child_argv[child_argc] = NULL;

    struct run_result rr = {0};
    int run_rc = run_in_sandbox(path, child_argv, &lim, no_net, use_jail, &rr);
    free(child_argv);

    if (run_rc != 0) {
        fprintf(stderr, "run failed\n");
        return EX_SANDBOX;
    }

    if (json) {
        if (pretty) {
            printf("{\n  \"run\": {\n    \"path\": \"%s\",\n    \"exit_code\": %d,\n    \"term_signal\": %d,\n    \"timeout\": %s,\n    \"elapsed_ms\": %ld\n  }\n}\n",
                   path, rr.exit_code, rr.term_signal, rr.killed_by_timeout ? "true":"false", rr.elapsed_ms);
        } else {
            printf("{\"run\":{\"path\":\"%s\",\"exit_code\":%d,\"term_signal\":%d,\"timeout\":%s,\"elapsed_ms\":%ld}}\n",
                   path, rr.exit_code, rr.term_signal, rr.killed_by_timeout ? "true":"false", rr.elapsed_ms);
        }
    } else {
        printf("ran %s  exit=%d  sig=%d  timeout=%d  elapsed=%ldms\n",
               path, rr.exit_code, rr.term_signal, rr.killed_by_timeout, rr.elapsed_ms);
    }

    /* Standardized exit code mapping for CI/scripts */
    if (rr.killed_by_timeout) return EX_TIMEOUT;
    if (rr.term_signal != 0)  return EX_SANDBOX;
    if (rr.exit_code  != 0)   return EX_SANDBOX;
    return EX_OK;
}

/* =======================
 * Phase 3 + 4: trace (ptrace + optional jail)
 * NOTE: we accept --timeout/--max, but CI does not rely on timeout here.
 * ======================= */
static int cmd_trace(int argc, char **argv) {
    if (argc < 1) {
        fprintf(stderr, "Usage: malx trace <path> [--timeout SEC] [--max N] [--jail] [--json] [--pretty] [--] [args...]\n");
        return EX_USAGE;
    }

    const char *path = argv[0];
    int timeout = 5, maxev = 200, json = 1, pretty = 0, use_jail = 0;

    int sep = -1;
    for (int i = 1; i < argc; i++) {
        if (!strcmp(argv[i], "--")) { sep = i; break; }
        else if (!strcmp(argv[i], "--timeout") && i+1 < argc) timeout = atoi(argv[++i]);
        else if (!strcmp(argv[i], "--max")     && i+1 < argc) maxev   = atoi(argv[++i]);
        else if (!strcmp(argv[i], "--jail"))   use_jail = 1;
        else if (!strcmp(argv[i], "--json"))   json   = 1;
        else if (!strcmp(argv[i], "--pretty")) pretty = 1;
    }

    int child_argc = 1 + ((sep >= 0) ? (argc - sep - 1) : 0);
    char **child_argv = calloc(child_argc + 1, sizeof(char*));
    if (!child_argv) { perror("calloc"); return EX_SANDBOX; }
    child_argv[0] = (char*)path;
    if (sep >= 0) for (int i = 0; i < argc - sep - 1; i++) child_argv[1+i] = argv[sep+1+i];
    child_argv[child_argc] = NULL;

    struct trace_opts topt = {
        .timeout_sec = timeout,
        .max_events  = maxev,
        .json        = json,
        .pretty      = pretty,
        .jail        = use_jail
    };

    int rc = trace_process(path, child_argv, &topt);
    free(child_argv);

    /* trace_process should already print (when json=1); just normalize exits: */
    if (rc == 0)         return EX_OK;
    else if (rc == EX_TIMEOUT) return EX_TIMEOUT;
    else if (rc == EX_USAGE)   return EX_USAGE;
    else                       return EX_SANDBOX;
}

/* =======================
 * main
 * ======================= */
int main(int argc, char **argv) {
    if (argc < 2) { print_usage(); return EX_USAGE; }

    if (!strcmp(argv[1], "--help"))    { print_usage(); return EX_OK; }
    if (!strcmp(argv[1], "--version")) { printf("malx %s\n", MALX_VERSION); return EX_OK; }

    if (!strcmp(argv[1], "static")) return cmd_static(argc-2, &argv[2]);
    if (!strcmp(argv[1], "run"))    return cmd_run   (argc-2, &argv[2]);
    if (!strcmp(argv[1], "trace"))  return cmd_trace (argc-2, &argv[2]);

    fprintf(stderr, "unknown subcommand: %s\n", argv[1]);
    print_usage();
    return EX_USAGE;
}
