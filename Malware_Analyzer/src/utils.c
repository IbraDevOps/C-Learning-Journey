#include "utils.h"
#include <stdio.h>
#include <stdlib.h>
#include <openssl/evp.h>

int read_file(const char *path, unsigned char **buf, size_t *len, char *err, size_t errlen) {
    *buf = NULL; *len = 0;
    FILE *f = fopen(path, "rb");
    if (!f) { snprintf(err, errlen, "cannot open file"); return -1; }
    if (fseek(f, 0, SEEK_END) != 0) { snprintf(err, errlen, "fseek end failed"); fclose(f); return -1; }
    long sz = ftell(f); if (sz < 0) { snprintf(err, errlen, "ftell failed"); fclose(f); return -1; }
    rewind(f);
    unsigned char *tmp = (unsigned char*)malloc((size_t)sz);
    if (!tmp) { snprintf(err, errlen, "malloc failed"); fclose(f); return -1; }
    size_t rd = fread(tmp, 1, (size_t)sz, f); fclose(f);
    if (rd != (size_t)sz) { free(tmp); snprintf(err, errlen, "short read"); return -1; }
    *buf = tmp; *len = (size_t)sz; return 0;
}

int sha256_hex(const unsigned char *buf, size_t len, char out_hex[65]) {
    unsigned char md[32]; unsigned int mdlen = 0;
    EVP_MD_CTX *ctx = EVP_MD_CTX_new(); if (!ctx) return -1;
    if (EVP_DigestInit_ex(ctx, EVP_sha256(), NULL) != 1) { EVP_MD_CTX_free(ctx); return -1; }
    if (EVP_DigestUpdate(ctx, buf, len) != 1) { EVP_MD_CTX_free(ctx); return -1; }
    if (EVP_DigestFinal_ex(ctx, md, &mdlen) != 1) { EVP_MD_CTX_free(ctx); return -1; }
    EVP_MD_CTX_free(ctx);
    static const char *hex = "0123456789abcdef";
    for (unsigned i = 0; i < 32; ++i) { out_hex[i*2] = hex[(md[i]>>4)&0xF]; out_hex[i*2+1] = hex[md[i]&0xF]; }
    out_hex[64] = '\0'; return 0;
}
