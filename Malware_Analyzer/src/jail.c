/* src/jail.c
 * Implements jail_enter(...) matching include/jail.h
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sched.h>       /* unshare(), CLONE_NEW* */
#include <sys/mount.h>   /* mount() */
#include <sys/stat.h>
#include <sys/types.h>
#include <errno.h>

#include "jail.h"

static int mkpath(const char *p, mode_t m) {
    /* create directories recursively (best-effort) */
    char tmp[512];
    size_t len = strlen(p);
    if (len == 0 || len >= sizeof(tmp)) return -1;
    memcpy(tmp, p, len+1);
    if (tmp[len-1] == '/') tmp[len-1] = '\0';
    for (char *q = tmp + 1; *q; ++q) {
        if (*q == '/') {
            *q = '\0';
            if (mkdir(tmp, m) != 0 && errno != EEXIST) return -1;
            *q = '/';
        }
    }
    if (mkdir(tmp, m) != 0 && errno != EEXIST) return -1;
    return 0;
}

static int bind_ro(const char *src, const char *dst, int readonly) {
    if (mkpath(dst, 0555) != 0) return -1;
    if (mount(src, dst, NULL, MS_BIND | MS_REC, NULL) != 0) return -1;
    if (readonly) {
        /* remount read-only */
        if (mount(NULL, dst, NULL, MS_REMOUNT | MS_BIND | MS_RDONLY | MS_REC, NULL) != 0)
            return -1;
    }
    return 0;
}

/* The header declares:
 * int jail_enter(const struct jail_opts *opt, char *err, size_t errlen);
 */
int jail_enter(const struct jail_opts *opt, char *err, size_t errlen) {
    if (!err || errlen == 0) return -1;
    if (!opt) {
        snprintf(err, errlen, "jail_enter: opt == NULL");
        return -1;
    }

    /* unshare mount namespace and optionally network namespace */
    int flags = CLONE_NEWNS;
    if (opt->make_netns) flags |= CLONE_NEWNET;
    if (unshare(flags) != 0) {
        snprintf(err, errlen, "unshare: %s", strerror(errno));
        return -1;
    }

    /* make mounts private so we don't accidentally affect host */
    if (mount(NULL, "/", NULL, MS_REC | MS_PRIVATE, NULL) != 0) {
        snprintf(err, errlen, "mount private: %s", strerror(errno));
        return -1;
    }

    /* choose root directory (user-specified or temp) */
    char root[256];
    if (opt->root) {
        /* copy safely */
        size_t rlen = strlen(opt->root);
        if (rlen >= sizeof(root)) {
            snprintf(err, errlen, "root path too long");
            return -1;
        }
        memcpy(root, opt->root, rlen+1);
        if (mkpath(root, 0755) != 0 && errno != EEXIST) {
            snprintf(err, errlen, "mkpath root %s: %s", root, strerror(errno));
            return -1;
        }
    } else {
        /* automatic temporary directory */
        char tmp_template[] = "/tmp/malx.XXXXXX";
        char *t = mkdtemp(tmp_template);
        if (!t) {
            snprintf(err, errlen, "mkdtemp: %s", strerror(errno));
            return -1;
        }
        /* mkdtemp modifies template in place */
        size_t tlen = strlen(tmp_template);
        if (tlen >= sizeof(root)) {
            snprintf(err, errlen, "temp root path too long");
            return -1;
        }
        memcpy(root, tmp_template, tlen+1);
    }

    /* create minimal tree under root */
    char path[512];
    struct { const char *sub; mode_t mode; } needed[] = {
        { "bin", 0555 },
        { "lib", 0555 },
        { "lib64", 0555 },
        { "usr", 0555 },
        { "proc", 0555 },
        { "tmp", 01777 },
        { NULL, 0 }
    };
    for (int i = 0; needed[i].sub; ++i) {
        int n = snprintf(path, sizeof(path), "%s/%s", root, needed[i].sub);
        if (n < 0 || (size_t)n >= sizeof(path)) {
            snprintf(err, errlen, "path buffer overflow");
            return -1;
        }
        if (mkpath(path, needed[i].mode) != 0 && errno != EEXIST) {
            snprintf(err, errlen, "mkdir %s: %s", path, strerror(errno));
            return -1;
        }
    }

    /* bind common host paths read-only into the jail (best-effort) */
    int ro = opt->readonly;
    /* construct destination paths and bind */
    #define TRY_BIND(S) do { \
        int _nn = snprintf(path, sizeof(path), "%s/" S, root); \
        if (!(_nn < 0 || (size_t)_nn >= sizeof(path))) bind_ro("/" S, path, ro); \
    } while(0)

    TRY_BIND("bin");
    TRY_BIND("lib");
    TRY_BIND("lib64");
    TRY_BIND("usr");
    #undef TRY_BIND

    /* chroot into the jail root and switch to "/" */
    if (chroot(root) != 0 || chdir("/") != 0) {
        snprintf(err, errlen, "chroot/chdir: %s", strerror(errno));
        return -1;
    }

    /* mount proc inside the new PID/ns (best-effort) */
    (void) mkdir("/proc", 0555);
    (void) mount("proc", "/proc", "proc", 0, NULL);

    /* success */
    return 0;
}
