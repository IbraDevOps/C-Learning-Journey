
#define _GNU_SOURCE
#include <errno.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/user.h>
#include <time.h>
#include <unistd.h>

#include "trace.h"

static long now_ms(void){
    struct timespec ts; clock_gettime(CLOCK_MONOTONIC, &ts);
    return (long)(ts.tv_sec*1000LL + ts.tv_nsec/1000000LL);
}

static void json_enter(long num, long a0,long a1,long a2,long a3,long a4,long a5, int pretty){
    if(pretty){
        printf("    {\"type\":\"enter\",\"num\":%ld,\"args\":[%ld,%ld,%ld,%ld,%ld,%ld]},\n",
               num,a0,a1,a2,a3,a4,a5);
    }else{
        printf("{\"type\":\"enter\",\"num\":%ld,\"args\":[%ld,%ld,%ld,%ld,%ld,%ld]},\n",
               num,a0,a1,a2,a3,a4,a5);
    }
}
static void json_exit(long num, long ret, int pretty){
    if(pretty){
        printf("    {\"type\":\"exit\",\"num\":%ld,\"ret\":%ld},\n", num, ret);
    }else{
        printf("{\"type\":\"exit\",\"num\":%ld,\"ret\":%ld},\n", num, ret);
    }
}

int trace_process(const char *path, char *const argv[], const struct trace_opts *opt){
#ifndef __x86_64__
    fprintf(stderr, "trace: only x86_64 is supported in this prototype\n");
    return 1;
#else
    int timeout = opt ? opt->timeout_sec : 5;
    int maxev   = opt ? opt->max_events : 200;
    int as_json = opt ? opt->json : 1;
    int pretty  = opt ? opt->pretty : 0;

    pid_t pid = fork();
    if(pid < 0){ perror("fork"); return 1; }

    long t0 = now_ms();
    int status = 0;

    if(pid == 0){
        /* child */
        if(ptrace(PTRACE_TRACEME, 0, NULL, NULL) < 0){ _exit(127); }
        raise(SIGSTOP);               /* let parent seize us */
        execv(path, argv);
        _exit(127);
    }

    /* parent */
    if(waitpid(pid, &status, 0) < 0){ perror("waitpid"); return 1; }
    if(ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_TRACESYSGOOD) < 0){ perror("PTRACE_SETOPTIONS"); return 1; }

    int events = 0;
    int entering = 1;

    if(as_json){
        if(pretty) puts("{\n  \"trace\": [");
        else       puts("{\"trace\":[");
    }

    while(1){
        if(ptrace(PTRACE_SYSCALL, pid, 0, 0) < 0){ perror("PTRACE_SYSCALL"); break; }
        if(waitpid(pid, &status, 0) < 0){ if(errno==EINTR) continue; perror("waitpid"); break; }

        if(WIFEXITED(status) || WIFSIGNALED(status)){
            break;
        }

        /* syscall stop? */
        if(WIFSTOPPED(status) && (WSTOPSIG(status) == (SIGTRAP | 0x80))){
            struct user_regs_struct r; 
            if(ptrace(PTRACE_GETREGS, pid, 0, &r) < 0){ perror("PTRACE_GETREGS"); break; }

            if(entering){
                /* x86_64 calling convention */
                long num = (long)r.orig_rax;
                long a0 = (long)r.rdi, a1=(long)r.rsi, a2=(long)r.rdx;
                long a3 = (long)r.r10, a4=(long)r.r8,  a5=(long)r.r9;

                if(as_json) json_enter(num,a0,a1,a2,a3,a4,a5, pretty);
                else        printf("enter  num=%ld args=[%ld,%ld,%ld,%ld,%ld,%ld]\n", num,a0,a1,a2,a3,a4,a5);

                entering = 0;
            }else{
                long num = (long)r.orig_rax;
                long ret = (long)r.rax;

                if(as_json) json_exit(num,ret, pretty);
                else        printf("exit   num=%ld ret=%ld\n", num, ret);

                entering = 1;
                if(maxev > 0 && ++events >= maxev){
                    kill(pid, SIGKILL);
                    (void)waitpid(pid, &status, 0);
                    break;
                }
            }
        }

        /* wall-clock timeout */
        if(timeout > 0 && (now_ms() - t0) >= (long)timeout*1000L){
            kill(pid, SIGKILL);
            (void)waitpid(pid, &status, 0);
            break;
        }
    }

    if(as_json){
        if(pretty) puts("  ]\n}");
        else       puts("]}");
    }
    return 0;
#endif
}

